<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Sahil Puri | Interactive Viewer</title>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.161.0/build/three.module.js"
  }
}
</script>
<style>
  :root{
    --porcelain:   #f7f7f2;
    --beige:       #e4e6c3;
    --palm-leaf:   #899878;
    --carbon-black:#222725;
    --onyx:        #121113;
  }
  html,body{
    height:100%;
    margin:0;
    background:#ffffff;              /* white page background */
    color:#000000;                   /* black text */
    font-family:-apple-system,BlinkMacSystemFont,sans-serif;
  }
  .nav{
    position:fixed;
    top:0;left:0;right:0;
    z-index:10;
    background:rgba(255,255,255,0.9);
    backdrop-filter:blur(10px);
    border-bottom:1px solid #e0e0e0;
  }
  .nav-inner{
    max-width:1100px;
    margin:0 auto;
    padding:12px 16px;
    display:flex;
    gap:16px;
    align-items:center;
  }
  .brand{
    font-weight:700;
    color:var(--carbon-black);
    text-decoration:none;
  }
  .tabs{
    margin-left:auto;
    display:flex;
    gap:10px;
  }
  .tab{
    color:#333333;
    text-decoration:none;
    padding:6px 10px;
    border-radius:8px;
    border:1px solid transparent;
  }
  .tab:hover{
    background:var(--porcelain);
    border-color:var(--beige);
  }
  #stage{
    position:absolute;
    inset:56px 0 0 340px;  /* leave room for nav + bio card */
    z-index:1;
  }
  .bio-card{
    position:fixed;
    top:56px;
    left:0;
    bottom:0;
    width:320px;
    background:rgba(255,255,255,0.95);
    border-right:1px solid #e0e0e0;
    padding:18px 16px 16px;
    box-shadow:6px 0 24px rgba(0,0,0,0.06);
    overflow:auto;
    display:flex;
    flex-direction:column;
    gap:14px;
    z-index:3;
  }
  .bio-label{
    font-size:11px;
    letter-spacing:0.08em;
    text-transform:uppercase;
    color:#666666;
  }
  .bio-title{
    font-size:20px;
    font-weight:700;
    color:var(--carbon-black);
    margin:0;
  }
  .bio-photo{
    width:100%;
    aspect-ratio:4/5;
    border-radius:14px;
    background:linear-gradient(135deg, #b7c2ab, #e4e6c3);
    border:1px solid #d6d6d6;
    box-shadow:0 10px 24px rgba(0,0,0,0.08);
  }
  .bio-text{
    font-size:14px;
    line-height:1.6;
    color:#333333;
    margin:0;
    white-space:pre-line;
  }
  .hint{
    position:fixed;
    left:16px;
    bottom:12px;
    color:#555555;
    font-size:12px;
    pointer-events:none;
  }
  .badge{
    position:fixed;
    right:12px;
    bottom:12px;
    background:rgba(255,255,255,0.9);
    border:1px solid #e0e0e0;
    color:#333333;
    padding:6px 10px;
    border-radius:8px;
    font-size:12px;
    box-shadow:0 4px 12px rgba(0,0,0,0.08);
  }
  .viewer-controls{
    position:fixed;
    left:360px;
    right:16px;
    bottom:16px;
    max-width:380px;
    margin:0;
    padding:4px;
    background:rgba(247,247,242,0.96);
    border:1px solid var(--beige);
    border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,0.12);
    color:var(--carbon-black);
    font-family:-apple-system,BlinkMacSystemFont,sans-serif;
    z-index:3;
    pointer-events:auto;
  }
  .viewer-controls .title{
    color:var(--carbon-black);
    letter-spacing:0.05em;
  }
  .viewer-controls .controller{
    border-color:rgba(137,152,120,0.25);
  }
</style>

</head>
<body>
  <nav class="nav">
    <div class="nav-inner">
      <a class="brand" href="index.html">Sahil Puri</a>
      <div class="tabs">
        <a class="tab" href="index.html">Home</a>
        <a class="tab" href="projects.html">Projects</a>
        <a class="tab" href="about.html">About</a>
      <a class="tab" href="contact.html">Contact</a>
      </div>
    </div>
  </nav>

  <aside class="bio-card">
    <div class="bio-label">Profile</div>
    <h2 class="bio-title">Your Name</h2>
    <div class="bio-photo"></div>
    <p class="bio-text">Filler bio copy goes here. Share a quick intro, current focus, favorite tools, and a highlight project or two. Use this space to tell people what drives you and how to reach out.

Add a brief tagline, a short list of specialties, or a motto that captures your vibe.</p>
  </aside>

  <div id="stage"></div>
  <div class="hint">Scroll = zoom · Right-drag = pan · Left-drag = orbit</div>
  <div class="badge">Viewer: PBR / Wireframe / Normals / UV / Matcap / Depth</div>

  <!-- Three.js & helpers (CDN) -->
  <script type="module">
    import * as THREE from "three";
    import {OrbitControls} from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";
    import {OBJLoader} from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/OBJLoader.js";
    import {MTLLoader} from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/MTLLoader.js";
    import {RGBELoader} from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/RGBELoader.js";
    import {GUI} from "https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js";

    // ---------- Basic scene ----------
    const container = document.getElementById("stage");
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#f7f7f2");

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.05, 200);
    camera.position.set(2.5, 1.6, 3.0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.enablePan = false; // disable panning per request
    controls.enableZoom = false; // disable zoom per request

    // ---------- Lights ----------
    const key = new THREE.DirectionalLight(0xffffff, 3.6); // stronger key
    key.position.set(5, 6, 4);

    const fill = new THREE.HemisphereLight(0xffffff, 0x666666, 1.6);

    const rim = new THREE.DirectionalLight(0xffffff, 1.9); // rim / back light
    rim.position.set(-4, 3, -6);

    scene.add(key, fill, rim);



    // ---------- Environment (optional HDR) ----------
    let envMap = null;
    try {
      new RGBELoader()
        .setPath("assets/")
        .load("studio.hdr", (hdr)=>{
          hdr.mapping = THREE.EquirectangularReflectionMapping;
          envMap = hdr;
          scene.environment = envMap;
          renderer.render(scene, camera);
        });
    } catch(e){ /* no HDR, fine */ }

    // ---------- Materials / Modes ----------
    const texLoader = new THREE.TextureLoader().setCrossOrigin('anonymous');
    // Generate a checker if none present (data URL)
    function makeChecker(size=512, squares=8){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      const s = size/squares;
      for(let y=0;y<squares;y++){
        for(let x=0;x<squares;x++){
          g.fillStyle = (x+y)%2 ? "#9a8c98" : "#f2e9e4";
          g.fillRect(x*s,y*s,s,s);
        }
      }
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1,1);
      return t;
    }
    const uvChecker = makeChecker();

    // Custom shaders for view/world normals & depth
    const normalVisMat = new THREE.ShaderMaterial({
      vertexShader: /* glsl */`
        varying vec3 vNormalVS;
        varying vec3 vNormalWS;
        void main(){
          vNormalWS = normalize(normalMatrix * normal);
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          vNormalVS = normalize(mat3(modelViewMatrix) * normal);
          gl_Position = projectionMatrix * mv;
        }`,
      fragmentShader: /* glsl */`
        varying vec3 vNormalVS;
        varying vec3 vNormalWS;
        uniform bool viewSpace;
        void main(){
          vec3 n = normalize(viewSpace ? vNormalVS : vNormalWS);
          n = n * 0.5 + 0.5; // map -1..1 to 0..1
          gl_FragColor = vec4(n,1.0);
        }`,
      uniforms: { viewSpace: {value: true} }
    });

    const depthVisMat = new THREE.ShaderMaterial({
      vertexShader: /* glsl */`
        varying float vDepth;
        void main(){
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          vDepth = -mv.z; // camera forward is -Z
          gl_Position = projectionMatrix * mv;
        }`,
      fragmentShader: /* glsl */`
        varying float vDepth;
        uniform float near;
        uniform float far;
        float linear01(float z){ return (z - near) / (far - near); }
        void main(){
          float d = clamp(linear01(vDepth), 0.0, 1.0);
          gl_FragColor = vec4(vec3(d), 1.0);
        }`,
      uniforms: { near:{value: camera.near}, far:{value: camera.far} }
    });

    const matcap = texLoader.load("https://raw.githubusercontent.com/nidorx/matcaps/master/256/6C6C6C_9C9C9C_DDDDDD_FFFFFF-256px.png");
    matcap.colorSpace = THREE.SRGBColorSpace;

    const materials = {
      PBR: new THREE.MeshStandardMaterial({color:"#899878", metalness:0.25, roughness:0.45, envMapIntensity:1.35}),
      Wireframe: new THREE.MeshBasicMaterial({color:"#f2e9e4", wireframe:true}),
      UV_Checker: new THREE.MeshBasicMaterial({map: uvChecker}),
      Matcap: new THREE.MeshMatcapMaterial({matcap}),
      Normals_View: normalVisMat,   // view space normals
      Normals_World: normalVisMat.clone(), // world space normals
      Depth: depthVisMat
    };
    materials.Normals_View.uniforms.viewSpace.value = true;
    materials.Normals_World.uniforms.viewSpace.value = false;

    // ---------- Load model (fallback if missing) ----------
    let modelRoot = new THREE.Group();
    scene.add(modelRoot);

    async function loadModel() {
      const objLoader = new OBJLoader().setPath("assets/");
      try{
        // Try to load materials if present (optional)
        try {
          const mtl = await new MTLLoader().setPath("assets/").loadAsync("model.mtl");
          mtl.preload();
          objLoader.setMaterials(mtl);
        } catch {/* no MTL, continue with geometry only */}

        const obj = await objLoader.loadAsync("model.obj");
        // Center around its bounding-box center so rotation pivots correctly
        const box = new THREE.Box3().setFromObject(obj);
        const center = new THREE.Vector3(); box.getCenter(center);
        obj.position.sub(center);
        obj.updateMatrixWorld(true);
        modelRoot.add(obj);
        // Fit camera to the centered root
        fitCameraToObject(modelRoot);
      } catch (e){
        // Fallback primitive (torus knot)
        const geo = new THREE.TorusKnotGeometry(0.6, 0.22, 256, 32);
        const mesh = new THREE.Mesh(geo, materials.PBR);
        modelRoot.add(mesh);
        fitCameraToObject(modelRoot);
      }
      applyMaterial(currentMode);
    }

    function fitCameraToObject(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov/2)));
      camera.position.copy(center).add(new THREE.Vector3(dist*1.6, dist*1.0, dist*1.6));
      camera.near = Math.max(0.01, dist/100);
      camera.far = dist*100;
      camera.updateProjectionMatrix();
      depthVisMat.uniforms.near.value = camera.near;
      depthVisMat.uniforms.far.value = camera.far;
      // Center the target so the model is centered on screen
      controls.target.copy(center);
      controls.update();
    }

    function setMaterialRecursive(obj, mat){
      obj.traverse((c)=>{
        if (c.isMesh){
          c.material = mat;
          c.material.needsUpdate = true;
        }
      });
    }

    let currentMode = "PBR";
    function applyMaterial(mode){
      currentMode = mode;
      // Enable/disable environment & lights depending on mode
      const useEnv = (mode === "PBR" || mode === "Matcap");
      scene.environment = useEnv ? envMap : null;
      key.visible = (mode === "PBR" || mode === "UV_Checker" || mode.startsWith("Normals") || mode==="Depth");
      fill.visible = key.visible;

      // For Matcap, lights are irrelevant
      if (mode === "Matcap") { key.visible = fill.visible = false; }

      // Apply
      const mat = materials[mode];
      setMaterialRecursive(modelRoot, mat);
    }

    // ---------- GUI ----------
    const gui = new GUI({title:"Viewer"});
    const params = {
      Mode: currentMode,
      ViewSpaceNormals: true,
      ToneMapping: "ACES",
      Exposure: 1.25,
      ResetCamera(){ fitCameraToObject(modelRoot); }
    };

    gui.add(params, "Mode", Object.keys(materials)).onChange(applyMaterial);
    gui.add(params, "ViewSpaceNormals").onChange(v=>{
      materials.Normals_View.uniforms.viewSpace.value = true;
      materials.Normals_World.uniforms.viewSpace.value = false;
      if (currentMode.startsWith("Normals")){
        applyMaterial(v ? "Normals_View" : "Normals_World");
      }
    });
    gui.add(params, "ToneMapping", ["ACES","Reinhard","Linear","None"]).onChange(v=>{
      renderer.toneMapping = ({
        "ACES": THREE.ACESFilmicToneMapping,
        "Reinhard": THREE.ReinhardToneMapping,
        "Linear": THREE.LinearToneMapping,
        "None": THREE.NoToneMapping
      })[v];
    });
    gui.add(params, "Exposure", 0.2, 2.5, 0.01).onChange(v=>{ renderer.toneMappingExposure = v; });
    gui.add(params, "ResetCamera");
    gui.domElement.classList.add("viewer-controls");

    // ---------- Animate ----------
    const clock = new THREE.Clock();
    const spinSpeed = 0.4; // radians per second
    function tick(){
      const dt = clock.getDelta();
      controls.update();
      // gentle spin around Y for the model
      if (modelRoot) modelRoot.rotation.y += spinSpeed * dt;
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // Resize
    window.addEventListener("resize", ()=>{
      renderer.setSize(container.clientWidth, container.clientHeight);
      camera.aspect = container.clientWidth/container.clientHeight;
      camera.updateProjectionMatrix();
    });

    // Go
    loadModel();
  </script>
</body>
</html>
